# 리액티브 프로그래밍

- 리액티브 스트림 구현체인 Flux와 Mono를 사용하여 데이터를 비동기로 바로 처리 가능
- 로직을 짤 때는 반드시 논블록킹하게 작성해야 함
  - 만약, 블록킹 코드가 있다면 `subscribeOn`과 `publishOn`을 사용하여 블록킹 코드를 별도의 스레드에서 실행하도록 해야 함
```java
// 블록킹 코드
Thread.sleep(500);
```

## 스레드

- 톰캣(프로세스)이 실행될 때 톰캣의 스레드(기본적으로 200개)를 생성
- 요청 시작부터 응답까지 톰캣의 스레드가 사용됨
- 스프링 부트는 애플리케이션이 실행될때 스레드풀을 생성함

### Tomcat vs Netty

- 톰캣은 요청이 들어오면 스레드를 할당하고, 응답이 끝나면 스레드를 반환함
- 네티는 스레드 1개가 여러 요청을 빠르게 처리할 수 있음
즉, 톰캣은 한 개의 스레드가 한 개의 요청을 끝까지 순서대로 처리하는 반면, 네티는 하나의 요청에 귀속되어 있는게 아닌 여러 가지 이벤트들을 계속해서 처리하는 구조임

- 톰캣의 스레드는 IO(블록킹) 작업을 직접 대기하며 작업을 처리함
- 네티는 IO 작업을 비동기로 처리하여 스레드가 다른 작업을 수행할 수 있도록 함
  - 단, 외부 API 호출이나 DB 작업 등에서 블로킹이 발생할 수 있음. 그래도 다른 스레드들이 논블록킹으로 작업되기 때문에 전체적인 성능은 향상됨

네티의 스레드는 대기가 발생하면 OS한테 알려주고, 다른 작업을 수행하다가 작업이 끝나면 이벤트 루프가 다시 스레드를 깨워서 작업을 처리함

네티는 적은 수의 스레드만을 사용하기 때문에 블로킹을 취약함

> **키워드** <br/>
> thread per request model vs event loop model

> **중요** <br/>
> CPU, 커널, 프로세스가 구분되어 있는데 프로세스에서 스레드를 원하는 만큼 생성하도록 이용할 수 있음
> 이때, 이 스레드들은 운영체제가 스케줄링을 해주기 때문에 CPU 자원 분배를 신경쓰지 않아도 됨


### 궁금

- 네티도 톰캣처럼 스레드를 수백개 미리 만들어놓으면 블로킹에 강해지지 않을까?
  - CPU는 작업이 필요한 스레드의 데이터를 캐시에 저장하고 처리함
  - 그래서 작업이 필요한 스레드가 바뀔때마다(컨텍스트 스위칭) 캐시를 다시 불러와야 함
  - 예를 들어, 스레드가 100개인데 CPU 캐시가 10개라면, 스레드가 계속해서 컨텍스트 스위칭을 하게 되어 CPU 캐시를 불러오는 비용어 커져서 컨텍스트 스위칭 비용이 커지게 됨
  - 따라서 네티는 기본적으로 물리적인 스레드의 개수와 같은 개수의 스레드를 사용하도록 설계되어 있음

---

## 블록킹과 비동기

- 대기가 필요한 작업은 중요한 스레드(이벤트 루프가 구독하는 스레드) 대신 별도의 스레드에서 처리해야 함

비동기로 블로킹 작업을 논블로킹 처리를 하는 예시

- 자바스크립트의 setTimeout - 브라우저 백그라운드 스레드가 대기
- 자바의 CompletableFuture - 우리가 지정한 스레드가 대기
- Netty의 이벤트 루프 패턴 - OS의 I/O 다중화 메커니즘이 대기
- Subscriber-Publisher 패턴 구현체인 Flux와 Mono - 스케줄러 스레드가 대기

